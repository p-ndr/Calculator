using System;
using System.Text;
using System.Collections.Generic;

namespace Calculator
{
	public class CustomParser
	{
		/*
		 * This class is designed to parse only the arithmetic expressions, transforming them to postfix expressions.
		 * Note that if operators and numbers are given separately, the expression is already postfix or psuedo-postfix
		 * and we can simply pass the StringBuilder of them to ArithmeticHandler().
		 * 
		 */

        private Dictionary<char, int> operations = new Dictionary<char, int>()
            {
			 /* Maps the operators to their precedence. */
				{'+', 1},
                {'-', 1},
				{'*', 2},
				{'/', 2},
				{'^', 3}
			};

        CustomStack<char> tokens;
		StringBuilder output; //acts as a queue.

		public CustomParser()
		{
			this.tokens = new CustomStack<char> ();
			this.output = new StringBuilder();
		}

		public string parseWithShuntingYard(string regex)
		{
			/*
			 * Implementation of Shunting Yard Algorithm.
			 * Psuedocode:
			 * https://brilliant.org/wiki/shunting-yard-algorithm/
			 * 
			 * @params Expression generated by user
			 * @return The expression in postfix ordering.
			 * 
			 */
			try
			{
				foreach (char c in regex)
				{
					if (isDigit(c)) // Case: digits/decimal point
					{
						output.Append(c);
					}
					else if (isOperator(c)) // Case: Operators
					{
						while (!tokens.isEmpty() && hasHigherPrecedence(c, tokens.top()))
						{
							output.Append(tokens.pop());
						}

						tokens.push(c);
					}
					else if (c == '(') // Case: left bracket
					{
						tokens.push(c);
					}
					else if (c == ')') // Case: right bracket
					{
						while (!tokens.isEmpty() && tokens.top() != '(')
						{
							output.Append(tokens.pop());
						}
						tokens.pop();
					}
					else // Any other thing - like spaces and stuff.
					{
						output.Append(c);
					}
					
				}
				while (!tokens.isEmpty()) // popping the rest of the stack
				{
					output.Append(tokens.pop());
				}
			}
			catch (Exception e)
			{
				Console.WriteLine("Parsing failed.");
				Console.WriteLine(e.Message);
				System.Environment.Exit(-1);
			}
			return output.ToString();
		}

		private bool isDigit(char d)
        {

            /*
			 * This method checks whether the input is a digit or not.
			 *
			 * @params: string d
			 * @return: bool
			 * 
			 */

			if (char.IsDigit(d))
            {
				return true;
            }
            else
            {
				return false;
            }
        }

		private bool isOperator(char o)
        {
			/*
			 * This method checks whether the char given is an operator or not.
			 * 
			 * @param: char o
			 * @return: bool
			 * 
			 */
			if (operations.ContainsKey(o))
            {
				return true;
            }
            else
            {
				bool valid = (char.Equals(o, '(') || char.Equals(o, ')') || char.Equals(o, ' ') || char.Equals(o, '_') || char.Equals(o, '.'));
				if ((!isDigit(o)) && !valid)
                {
					throw new InvalidOperatorException();
                }
                else
                {
					return false;
				}
            }
        }

		private bool hasHigherPrecedence(char current, char next)
        {
			/*
			 * This method checks whether the current operation has higher precedence than the next,
			 * or not.
			 * 
			 * @param current operator as char, next operator as char
			 * @return boolean showing whether the next operator is actually an operator
			 *			and has higher precedence than the current one.
			 *			
			 */	
			return operations.ContainsKey(next) && operations[current] <= operations[next];
        }
	}
}
